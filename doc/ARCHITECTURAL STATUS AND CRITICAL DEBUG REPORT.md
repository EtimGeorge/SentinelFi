This detailed report provides a complete architectural status and pinpoints the final, elusive bug. This document can be handed over to a senior expert developer for immediate diagnosis.

---

# ARCHITECTURAL STATUS AND CRITICAL DEBUG REPORT

**TO:** Senior Expert Developer / External AI Debugging Agent
**FROM:** Senior Full-Stack Solutions Architect (SentinelFi Project)
**DATE:** December 22, 2025
**SUBJECT:** **CRITICAL LOGIN FAILURE: BCrypt Hash Mismatch Despite Destructive Re-Seeding**

## 1. Executive Summary: The Final Bug

The entire application is architecturally sound and stable, except for one critical issue: **The `bcrypt.compare` function is consistently returning `false` for a password that was just used to create the hash.**

*   **Problem:** The core financial security layer (login) is blocked.
*   **Status:** The security layer logic is correct. The failure is now definitively a **Data Integrity/Environment Protocol issue** where the hash generated by the `UserEntity` is corrupted or non-standard, or the comparison is failing due to environmental factors.
*   **Evidence:** The login succeeds only when password validation is completely bypassed (Step 94), proving the token/cookie/redirection flow is otherwise correct.

## 2. Project Status & Environment

| Layer | Component | Status | Code Context / Environment |
| :--- | :--- | :--- | :--- |
| **Backend** | NestJS (Node.js) | Stable (Local) | Running via `ts-node-dev` on `http://127.0.0.1:3000`. |
| **Frontend** | Next.js (React) | Stable (Local) | Running via `npm run dev` on `http://localhost:3001`. |
| **Database** | Neon (PostgreSQL) | Stable (External) | Connection confirmed. All schema/tables created via manual DDL. |
| **Security Model** | JWT | Correct | Fully implemented with **`HttpOnly` cookies**. `login` sets cookie, `test-secure` validates it. |
| **CORS/Protocol** | Protocol | Correct | `next.config.js` proxy and `main.ts` `cookieParser`/`enableCors` are correctly configured for cross-port communication. |
| **Last Action**| Final Attempt | Failure | **Destructive re-seed** using plaintext `'P@ssw0rd'` (Step 93) was executed, followed by a login attempt that failed validation. |

## 3. The Definitive Smoking Gun (Final Log Trace)

The following sequence confirms the final, most baffling data problem:

| Backend Action | Log Output | Conclusion |
| :--- | :--- | :--- |
| **Seeding** | `query: DELETE FROM "public"."user"...` (Destructive wipe) | Data is fresh. |
| **Seeding** | `- RE-SEEDED user: ... and PWD: P@ssw0rd` | User created with the plaintext password. |
| **Login** | `query: SELECT ... FROM "public"."user" WHERE...` | **SUCCESS:** User found. |
| **Login** | `DEBUG 1: User found. Validating password.` | **SUCCESS:** Validation starts. |
| **Login** | `FINAL DATA CHECK FAILURE: Password Sent: P@ssw0rd` | **SUCCESS:** Frontend sent the correct string. |
| **Login** | `DEBUG 2: Password validation failed` | **FAILURE:** `bcrypt.compare` failed. |

## 4. Source Code for Inspection

The expert needs to inspect the point of hashing (`UserEntity`) and the point of comparison (`AuthService`).

### A. Backend: `backend/src/auth/user.entity.ts` (Point of Hashing)

This is where the password is initially hashed on user creation.

```typescript
import { Entity, PrimaryGeneratedColumn, Column, BeforeInsert } from 'typeorm';
import * as bcrypt from 'bcrypt';
import { Role } from './enums/role.enum'; 

@Entity({ name: 'user', schema: 'public' }) 
export class UserEntity {
  @PrimaryGeneratedColumn('uuid')
  id!: string;
  @Column({ unique: true })
  email!: string;
  @Column({ select: false }) 
  password_hash!: string;
  @Column({ type: 'enum', enum: Role, default: Role.AssignedProjectUser })
  role!: Role;
  @Column({ default: true })
  is_active!: boolean;
  @Column({ type: 'timestamptz', default: () => 'CURRENT_TIMESTAMP' })
  created_at!: Date;
  
  // CRITICAL SECTION: The hashing mechanism
  @BeforeInsert()
  async hashPassword() {
    if (this.password_hash) {
      const salt = await bcrypt.genSalt(10); // Default cost factor
      this.password_hash = await bcrypt.hash(this.password_hash, salt);
    }
  }
}
```

### B. Backend: `backend/src/auth/auth.service.ts` (Point of Comparison)

This is the code that is failing on the `bcrypt.compare` line.

```typescript
// ... existing imports
import * as bcrypt from 'bcrypt'; 
// ...

@Injectable()
export class AuthService {
  // ... constructor ...

  async login(loginDto: LoginUserDto): Promise<{ access_token: string, user_role: Role }> {
    
    const user = await this.usersRepository.findOne({ 
      where: { email: loginDto.email },
      select: ['id', 'email', 'password_hash', 'role', 'is_active'], 
    });

    if (!user || !user.is_active) {
      throw new UnauthorizedException('Invalid credentials or user is inactive.');
    }
    
    // DEBUG LOGS BEFORE FAILURE:
    // console.log('FINAL DATA CHECK FAILURE: Hash in DB:', user.password_hash.substring(0, 15) + '...');
    // console.log('FINAL DATA CHECK FAILURE: Password Sent:', loginDto.password);

    // CRITICAL FAILURE LINE: bcrypt.compare returns false
    const passwordValid = await bcrypt.compare(loginDto.password, user.password_hash);
    
    if (!passwordValid) {
      // THIS IS THE BLOCK THAT IS EXECUTING
      throw new UnauthorizedException('Invalid credentials.');
    }
    
    // ... rest of JWT generation (which is proven to work)
    // ...
  }
}
```

## 5. Request to Expert Developer

**The Problem:** The `bcrypt.hash` inside the `UserEntity.@BeforeInsert` hook is producing an output that cannot be validated by `bcrypt.compare` immediately after creation, despite all code paths being identical.

**The Request:** Investigate why `bcrypt` is failing its own validation in this Node.js/TypeORM local environment. The likely causes are:
1.  **Async/Awaited Context Failure:** The `this.password_hash` in `UserEntity` is not yet the plaintext when `hashPassword` runs in the `BeforeInsert` hook, or the hook is running twice.
2.  **Missing `bcrypt` dependency chain issue:** The Node.js environment is using a fallback or incompatible version of `bcrypt` where `hash` and `compare` are not linked correctly, or a required import is missing from an intermediary file.

The next step should be to move the hashing logic *out* of the `UserEntity` hook and manually hash the password *before* saving it in the `AuthService.registerTestUser` function to ensure the hashing context is correct.
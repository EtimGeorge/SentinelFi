import { Injectable, ConflictException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { WbsBudgetEntity } from './wbs-budget.entity';
import { LiveExpenseEntity } from './live-expense.entity';
import { CreateWbsBudgetDto } from './dto/create-wbs-budget.dto';
import { CreateLiveExpenseDto } from './dto/create-live-expense.dto'; // <-- New Import

@Injectable()
export class WbsService {
  constructor(
    @InjectRepository(WbsBudgetEntity)
    private wbsRepository: Repository<WbsBudgetEntity>,
    @InjectRepository(LiveExpenseEntity)
    private expenseRepository: Repository<LiveExpenseEntity>,
  ) {}
  
  /**
   * Phase 2 Deliverable: CRUD for WBS/Budget (Create Draft)
   * Enforces WBS Code uniqueness and saves the budget as a DRAFT.
   */
  async createWbsBudgetDraft(createWbsDto: CreateWbsBudgetDto): Promise<WbsBudgetEntity> {
    
    // 1. Business Constraint: Check for existing WBS Code (Uniqueness)
    const existingWbs = await this.wbsRepository.findOne({ 
      where: { wbs_code: createWbsDto.wbs_code },
    });

    if (existingWbs) {
      throw new ConflictException(`WBS Code '${createWbsDto.wbs_code}' already exists.`);
    }

    // 2. Data Preparation: Create the entity instance
    const newWbsDraft = this.wbsRepository.create({
      ...createWbsDto,
      is_approved: false, // MANDATORY: All new entries are drafts until Finance (Phase 3) approves
    });

    // 3. Save to Database (ACID Transaction)
    // The total_cost_budgeted column is auto-generated by PostgreSQL, so we only save the inputs.
    return this.wbsRepository.save(newWbsDraft);
  }

  /**
   * Phase 2 Deliverable: Live Expense Entry (The primary write operation)
   * This method executes the mandated variance calculation *on commit*.
   */
  async logLiveExpenseEntry(expenseDto: CreateLiveExpenseDto, userId: string): Promise<LiveExpenseEntity> {
    // 1. Business Constraint: Check if the WBS ID exists.
    const wbsBudget = await this.wbsRepository.findOne({ where: { wbs_id: expenseDto.wbs_id } });

    if (!wbsBudget) {
      throw new NotFoundException(`WBS ID ${expenseDto.wbs_id} not found in the budget.`);
    }
    
    // 2. Automated: Variance Calculation (MANDATORY REQUIREMENT)
    const varianceResult = this.calculateLiveExpenseVariance(wbsBudget, expenseDto);

    // 3. Data Preparation: Create the expense entity
    const newExpense = this.expenseRepository.create({
      ...expenseDto,
      user_id: userId, // Enforced accountability from the authenticated token
      variance_flag: varianceResult.flag, // Result of the real-time calculation
    });

    // 4. Save to Database (ACID Transaction)
    return this.expenseRepository.save(newExpense);
  }
  
  /**
   * Phase 2 Deliverable: WBS/Budget Read Operation (Production-Ready Hierarchy and Rollup)
   * Uses a Recursive CTE (Common Table Expression) for performant, single-query retrieval
   * of the WBS hierarchy and the total aggregated spending against each WBS item.
   */
  async findAllWbsBudgetsWithRollup(): Promise<any[]> {
    // This will be dynamically determined in Phase 3 (RBAC/Multi-Tenancy).
    const clientSchema = 'client_template';
    
    const rawQuery = `
      -- 1. Anchor: Start at all root-level WBS items (parent_wbs_id IS NULL)
      WITH RECURSIVE wbs_tree AS (
        SELECT
          wb.wbs_id,
          wb.parent_wbs_id,
          wb.wbs_code,
          wb.description,
          wb.total_cost_budgeted,
          -- Calculate Total Paid Amount for this specific WBS item
          COALESCE((
            SELECT SUM(le.actual_paid_amount)
            FROM ${clientSchema}.live_expense le
            WHERE le.wbs_id = wb.wbs_id
          ), 0.00) AS total_paid_self
        FROM ${clientSchema}.wbs_budget wb
        WHERE wb.parent_wbs_id IS NULL

        UNION ALL

        -- 2. Recursive Step: Join to find children
        SELECT
          wb.wbs_id,
          wb.parent_wbs_id,
          wb.wbs_code,
          wb.description,
          wb.total_cost_budgeted,
          -- Calculate Total Paid Amount for this specific WBS item
          COALESCE((
            SELECT SUM(le.actual_paid_amount)
            FROM ${clientSchema}.live_expense le
            WHERE le.wbs_id = wb.wbs_id
          ), 0.00) AS total_paid_self
        FROM ${clientSchema}.wbs_budget wb
        JOIN wbs_tree wt ON wb.parent_wbs_id = wt.wbs_id
      )
      
      -- 3. Final Aggregation: Sum up total paid from all self and children
      SELECT
        wt.wbs_id,
        wt.parent_wbs_id,
        wt.wbs_code,
        wt.description,
        CAST(wt.total_cost_budgeted AS NUMERIC(19, 4)) AS total_cost_budgeted,
        -- Calculate Total Paid (Rollup) - This is the final aggregated value
        (
          SELECT SUM(CAST(t2.total_paid_self AS NUMERIC(19, 4)))
          FROM wbs_tree t2
          WHERE t2.wbs_code LIKE (wt.wbs_code || '%')
        ) AS total_paid_rollup,
        CAST(wt.total_paid_self AS NUMERIC(19, 4)) AS total_paid_self
      FROM wbs_tree wt
      ORDER BY wt.wbs_code ASC;
    `;

    // Note: The CASTs are added to ensure TypeORM returns correct numeric types.
    return this.wbsRepository.query(rawQuery);
  }

  /**
   * Helper function to perform the live variance calculation.
   * Variance (NGN) = (Budgeted Cost of Item) - (Actual Paid Amount)
   */
  private calculateLiveExpenseVariance(wbsBudget: WbsBudgetEntity, expenseDto: CreateLiveExpenseDto): { variance: number, flag: string } {
    
    // The budget is against the total cost of the item. For the initial variance flag, we compare the single expense against the item's budget.
    const budgetedTotal = wbsBudget.total_cost_budgeted;
    const actualPaid = expenseDto.actual_paid_amount;
    
    // Cast to Number for JavaScript arithmetic
    const variance = Number(budgetedTotal) - Number(actualPaid); 
    
    let flag = 'NO_VARIANCE';

    if (variance < 0) {
      flag = 'NEGATIVE_VARIANCE'; // Cost Overrun (Actual Paid > Budgeted Total)
    } else if (variance > 0) {
      flag = 'POSITIVE_VARIANCE'; // Cost Underrun
    }

    return { variance, flag };
  }
}